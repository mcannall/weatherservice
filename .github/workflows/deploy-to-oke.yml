name: Deploy to Oracle Kubernetes Engine

on:
  workflow_run:
    workflows: 
      - "Route Weather Planner CI/CD"
    types:
      - completed
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    name: Deploy to OKE
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    permissions:
      contents: read
      packages: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Install and configure OCI CLI
        run: |
          # Install OCI CLI
          curl -L -O https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh
          chmod +x install.sh
          ./install.sh --accept-all-defaults
          echo "$HOME/oracle-cli/bin" >> $GITHUB_PATH
          
          # Configure OCI CLI
          mkdir -p ~/.oci
          echo "${{ secrets.OCI_PRIVATE_KEY }}" > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem
          
          # Create config file
          cat > ~/.oci/config << EOF
          [DEFAULT]
          user=${{ secrets.OCI_CLI_USER }}
          fingerprint=${{ secrets.OCI_CLI_FINGERPRINT }}
          tenancy=${{ secrets.OCI_CLI_TENANCY }}
          region=${{ secrets.OCI_REGION }}
          key_file=~/.oci/oci_api_key.pem
          EOF
          chmod 600 ~/.oci/config

      - name: Configure kubectl
        run: |
          oci ce cluster create-kubeconfig \
            --cluster-id ${{ secrets.OCI_CLUSTER_ID }} \
            --file $HOME/.kube/config \
            --region ${{ secrets.OCI_REGION }} \
            --token-version 2.0.0
          chmod 600 $HOME/.kube/config

      - name: Create secrets
        run: |
          # Create or update the secrets
          kubectl create secret generic weatherservice-secrets \
            --from-literal=OPENWEATHERMAP_API_KEY=${{ secrets.OPENWEATHERMAP_API_KEY }} \
            --from-literal=GOOGLE_MAPS_API_KEY=${{ secrets.GOOGLE_MAPS_API_KEY }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify and wait for images
        run: |
          # Get the short SHA
          SHORT_SHA=$(echo ${{ github.event.workflow_run.head_sha }} | cut -c1-7)
          
          # Function to verify image availability with retries
          verify_image() {
            local image=$1
            local max_attempts=10
            local wait_time=30
            
            echo "Verifying availability of image: $image"
            
            for i in $(seq 1 $max_attempts); do
              if docker pull $image >/dev/null 2>&1; then
                echo "✓ Successfully pulled image: $image"
                return 0
              fi
              echo "Attempt $i/$max_attempts: Image not available yet. Waiting ${wait_time}s..."
              sleep $wait_time
            done
            
            echo "✗ Failed to verify image: $image after $max_attempts attempts"
            return 1
          }
          
          # Verify both images
          verify_image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/route-weather-planner:sha-$SHORT_SHA" || exit 1
          verify_image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-$SHORT_SHA" || exit 1

      - name: Update Kubernetes Deployments with retries
        run: |
          # Get the short SHA
          SHORT_SHA=$(echo ${{ github.event.workflow_run.head_sha }} | cut -c1-7)
          
          # Function to update deployment with retries
          update_deployment() {
            local deployment=$1
            local container=$2
            local image=$3
            local max_attempts=5
            local wait_time=30
            
            echo "Updating deployment: $deployment"
            
            for i in $(seq 1 $max_attempts); do
              if kubectl set image deployment/$deployment $container=$image; then
                echo "✓ Successfully updated deployment: $deployment"
                return 0
              fi
              echo "Attempt $i/$max_attempts: Failed to update deployment. Waiting ${wait_time}s..."
              sleep $wait_time
            done
            
            echo "✗ Failed to update deployment: $deployment after $max_attempts attempts"
            return 1
          }
          
          # Update deployments with retries
          update_deployment "route-planner" "route-planner" "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/route-weather-planner:sha-$SHORT_SHA" || exit 1
          update_deployment "weather-api" "api" "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-$SHORT_SHA" || exit 1

      - name: Wait for deployments with enhanced monitoring
        run: |
          # Function to wait for deployment with detailed status
          wait_for_deployment() {
            local deployment=$1
            local timeout=300  # 5 minutes timeout
            local interval=10  # Check every 10 seconds
            local elapsed=0
            
            echo "Waiting for deployment: $deployment"
            
            while [ $elapsed -lt $timeout ]; do
              # Get deployment status
              local status=$(kubectl rollout status deployment/$deployment --timeout=5s 2>&1)
              local exit_code=$?
              
              if [ $exit_code -eq 0 ]; then
                echo "✓ Deployment $deployment successfully rolled out"
                return 0
              fi
              
              # Get pod status for debugging
              echo "Current pod status for $deployment:"
              kubectl get pods -l app=weatherservice -o wide
              
              # Get events for debugging
              echo "Recent events:"
              kubectl get events --sort-by='.lastTimestamp' | tail -n 5
              
              elapsed=$((elapsed + interval))
              echo "Waiting... ($elapsed/${timeout}s)"
              sleep $interval
            done
            
            echo "✗ Deployment $deployment failed to roll out within ${timeout}s"
            return 1
          }
          
          # Wait for both deployments
          wait_for_deployment "weather-api" || exit 1
          wait_for_deployment "route-planner" || exit 1

      - name: Verify Service Endpoints
        run: |
          echo "Verifying service endpoints..."
          
          # Get service information
          echo "Weather API Service:"
          kubectl get service weather-api-service -o wide
          
          echo "Route Planner Service:"
          kubectl get service route-planner-service -o wide
          
          # Get pod logs
          echo "Weather API logs:"
          kubectl logs -l app=weatherservice,component=api --tail=50
          
          echo "Route Planner logs:"
          kubectl logs -l app=weatherservice,component=route-planner --tail=50 